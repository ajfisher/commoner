<!doctype>
<html>
    <head>
    </head>
    <body>
        <canvas width="512" height="512" id="cv" style="border:1px solid #000"></canvas>
        <script type="text/javascript">


            var rd = {
                init:  function(opts) {

                    var opts = opts || {};

                    // da: diffusion rate of A
                    // db: diffusion rate of B
                    // f:  feed rate of A into the system
                    // k:  kill rate of B from the system
                    // h:  time unit to increment by
                    this.da = opts.da || 1.0;
                    this.db = opts.db || 0.5;
                    this.f = opts.f || 0.155;
                    this.k = opts.k || 0.062;
                    this.h = opts.h || 0.1;
                    this.cellsize = opts.cellsize || 16;

                    this.generations = 0; // counts how many generations we've run

                    this.canvas = document.getElementById('cv');
                    this.ctx = this.canvas.getContext('2d');

                    this.width = this.canvas.width / this.cellsize;
                    this.height = this.canvas.height / this.cellsize;

                    this.cells = {
                        a: new Float32Array(this.width * this.height),
                        b: new Float32Array(this.width * this.height),
                    };

                    this.cells.a.fill(1);
                    this.cells.b.fill(0);

                    // 3x3 represented as vector in column major order
                    this.weights = [0.05, 0.2, 0.05, 0.2, -1, 0.2, 0.05, 0.2, 0.05];
                    // used to hold a lookup table of the relevant indices in the
                    // cells array to calculate the laplacian operator
                    this.laplacian_lookup = [];

                    this.create_laplacian_lookup({
                        kernel: { w: 3, h: 3 },
                    });

                    this.feedpoints = opts.feedpoints || [{ x: this.width/2, y: this.height/2  }];
                    // take the mid point of the cells and then just drop a
                    // an aditional point around them. Effectively a 9 cell blob
                    // of B rather than 1 point.
                    //this.cells.b[this.width/2 * this.height + this.height/2] = 1.0;
                    for (var lx = -1; lx <= 1; lx++) {
                        for (var ly = -1; ly <= 1; ly++) {
                            var gx = this.width/2 + lx;
                            var gy = this.height/2 + ly;
                            this.cells.b[gx * this.height + gy] = 1.0;
                        }
                    }
                    console.log(this);
                    this.diffuse(); // call this once to set the initial conditions
                },

                draw: function() {
                    // draws the current state of the system on the canvas
                    var cellsize = this.cellsize;
                    this.ctx.clearRect(0,0, this.canvas.width, this.canvas.height);
                    for (var x = 0; x < this.width; x++) {
                        for (var y = 0; y < this.height; y++) {
                            //var a = this.cells[x][y].a;
                            var b = this.cells.b[x * this.height + y];

                            if (b > this.minB) {
                                var val = (b - this.minB) / (this.maxB - this.minB);
                                this.ctx.fillStyle = "rgba(0, 0, 0, " + val + ")";
                                this.ctx.fillRect(x*cellsize, y*cellsize, cellsize, cellsize);
                            }
                        }
                    }
                },

                diffuse: function(dbg) {
                    // iterates over the cells and calculates the diffusion.

                    var debug = dbg || false;
                    var minA = maxA = 0;
                    var minB = maxB = 0;
                    var f = this.f;
                    var k = this.k;
                    var cells = this.cells;
                    var ci = 0;
                    for (var x = 0; x < this.width; x++) {
                        for (var y = 0; y < this.height; y++) {

                            var lap = this.laplacian(ci);
                            //var ci = x * this.height + y; // calc cell index once.
                            var a = cells.a[ci];
                            var b = cells.b[ci];
                            var abb = a * b * b;
                            // use this to only allow feed in at a singular point
                            // rather than across the entirety of the surface
                            /**for (var i=0; i< this.feedpoints.length; i++) {
                                if (x == this.feedpoints[i].x && y == this.feedpoints[i].y) {
                                    f = this.f;
                                }
                            }
                            //var A = a + (this.da * lap.a + f * (1.0 - a)) * this.h;
                            //var B = b + (this.db * lap.b - (this.k + f) * b) * this.h**/

                            var A = a + (this.da * lap.a - abb + f * (1.0 - a)) * this.h;
                            var B = b + (this.db * lap.b + abb - (k + f) * b) * this.h

                            if (A < 0) { A = 0.0; }
                            if (B < 0) { B = 0.0; }

                            if (debug) {
                                console.log("x: %s y: %s ci: %s a: %s A: %s  b: %s B: %s", x, y, ci, a, A,  b, B); 
                            }
                            this.cells.a[ci] = A;
                            this.cells.b[ci] = B;

                            if (A < minA) { minA = A; }
                            if (A > maxA) { maxA = A; }
                            if (B < minB) { minB = B; }
                            if (B > maxB) { maxB = B; }
                            ci++; // increment cell index counter
                        }
                    }

                    this.minA = minA;
                    this.minB = minB;
                    this.maxA = maxA;
                    this.maxB = maxB;

                    this.generations++;

                    if (debug) {
                        console.log("Gen: %s", this.generations);
                        console.log("<A: %s >A: %s <B: %s >B: %s", minA, maxA, minB, maxB);
                    }
                },

                laplacians: function() {
                    // calculates the laplacian values for the entire grid in strips
                },

                create_laplacian_lookup: function(opts) {
                    // creates a lookup table of the indices used to calculate
                    // the laplacian operator. As each cell always uses the same
                    // adjacent cells nearby we don't need to calculate this
                    // constantly in each generation.

                    var kw = opts.kernel.w || 3;
                    var kh = opts.kernel.h || 3;

                    // get shape of the cells
                    var cw = this.width;
                    var ch = this.height;

                    var lap_indices = [];

                    // iterate over the cell shape and for each cell determine
                    // the indices of adjacent cells according to the kernel distribution
                    for (var x = 0; x < (cw); x++) {
                        for (var y = 0; y < (ch); y++) {

                            var ci = []; // array of indices that reference the adjacent cells
                            // TODO make this work using any sized kernel only works for 3x3 at moment
                            for (var lx = x-1; lx <= x+1; lx++) {
                                for (var ly = y-1; ly <= y+1; ly++) {
                                    if (lx < 0 || lx > this.width-1 || ly < 0 || ly > this.height-1) {
                                        // detect an edge so push an invalid position
                                        ci.push(-1);
                                    } else {
                                        ci.push(lx*this.height + ly);
                                    }
                                }
                            }

                            lap_indices.push(ci);
                        }
                    }

                    this.laplacian_lookup = lap_indices;
                },

                laplacian: function(cell_index) {
                    // calculates the weighted average of surrounding cells from the
                    // current one
                    var conc = { a: 0, b: 0};

                    var ci = this.laplacian_lookup[cell_index];

                    for (var wi = 0; wi < this.weights.length; wi++) {
                        if (ci[wi] == -1) {
                            conc.a += 0;
                            conc.b += 0;
                        } else {
                            conc.a = conc.a + (this.weights[wi] * this.cells.a[ci[wi]]);
                            conc.b = conc.b + (this.weights[wi] * this.cells.b[ci[wi]]);
                        }
                    }

                    return (conc);
                },

                update: function() {
                    // does a frame update
                    this.draw();
                    window.requestAnimationFrame(function() {
                        this.update();
                    }.bind(this));
                },

                run: function(speed) {
                    // runs the diffuse function
                    var ms = speed || 100;

                    this.interval = window.setInterval(function() {
                        var a = performance.now();
                        rd.diffuse();
                        var b = performance.now();
                        console.log("Perf time %s", (b-a));
                    }, ms);
                },

                stop: function() {
                    window.clearInterval(this.interval);
                    console.log("Generation: %s", this.generations);
                },

                step: function(steps) {
                    // steps the diffuse function this many steps forward
                    for (var i=0; i< steps; i++) {
                        this.diffuse(true);
                    }
                },
            };

            rd.init({
                da: 1.0,
                db: 0.5,
                f: 0.0367,
                k: 0.0649,
                h: 1,
                cellsize: 1,
                feedpoints: [
                    {x: 20, y: 20},
                    {x: 50, y: 10},
                    {x: 40, y: 30}
                ],
            });
            window.requestAnimationFrame(function() {
                rd.update();
            });
        </script>
    </body>
</html>
